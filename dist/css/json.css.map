{"version":3,"sources":["utilities/_json-api.scss"],"names":[],"mappings":"AAoLE,uxFAA4B","file":"json.css","sourcesContent":["// JSON Export Utilities\n// ---------------------\n\n\n/// ## Exporting Styles to JSON\n///\n/// While many UX patterns will be rendered as HTML components,\n/// there are several abstract style patterns --\n/// like color-palettes and font-specimens --\n/// that never appear as components in the application.\n///\n/// Herman provides several `@preview` annotations\n/// to help visualize these abstract patterns --\n/// but that requires passing the data from your styles\n/// to Herman's templates.\n/// We do that using Sass maps\n/// (`key:value` object variables)\n/// and the `herman-export` mixin\n/// to generate JSON out of Sass variables.\n///\n/// @group api_json-export\n/// @see herman-export\n///\n/// @example scss\n///   @include herman-export;\n\n\n// Herman\n// ------\n/// Use this map to collect and organize\n/// color, font, size, and ratio values\n/// to be exported for Herman.\n///\n/// The `$herman` map should be structured\n/// with top-level keys representing individual sassdoc items.\n/// Top-level values will often be a nested map\n/// of the data to preview.\n/// Use the `herman-add` or `accoutrement-add` mixins\n/// to automatically populate\n/// fonts, colors, sizes, and ratios from existing maps --\n/// or construct your `$herman` map by hand,\n/// following these guidelines...\n///\n/// ### Map structure\n///\n/// Each type of preview value should be nested inside\n/// a map that describes what type of data is being stored:\n///\n/// ```scss\n/// $herman: (\n///   'colors': (\n///     /* color maps */\n///   );\n///   'sizes': (\n///     /* color maps */\n///   );\n///   'ratios': (\n///     /* color maps */\n///   );\n///   'fonts': (\n///     /* color maps */\n///   );\n/// );\n/// ```\n///\n/// ### Colors\n///\n/// Each color has an access name and value.\n/// For us, that is often a map-key string,\n/// and Sass hex/rgba output color:\n///\n/// ```scss\n/// 'brand-colors': (\n///   'brand-orange': '#c75000',\n///   'brand-blue': '#0d7fa5',\n/// )\n/// ```\n///\n/// If you are storing colors in variables,\n/// you may want to use name keys like `$brand-orange`\n/// to represent the proper use of a color.\n///\n/// Color values can be in any valid web-color format --\n/// hex, hsl/a, rgba/a, etc --\n/// converted to a valid JSON string.\n///\n/// ### Sizes & Ratios\n///\n/// Size and ratio data is similar to colors,\n/// organized into top-level groups that may contain\n/// one or more size/ratio key:value pairs:\n///\n/// ```scss\n/// 'font-ratios': (\n///   'line-height': '1.4',\n///   'minor-seventh': '16/9',\n/// ),\n/// 'text-sizes': (\n///   'root': '18px',\n///   'large': 'calc(1rem + 1.5vw)',\n/// )\n/// ```\n///\n/// Ratio values can be in any valid number,\n/// and size values should be valid CSS lengths --\n/// both converted to a valid JSON string.\n///\n/// ### Fonts\n///\n/// Each font should have a top-level key of its own,\n/// since font-previews display a single font at a time.\n/// The data map accepts:\n///\n/// - `name`: how the font should be referenced in CSS (if omitted, defaults to top-level key)\n/// - `stack`: optional string or list of font-stack fallbacks\n/// - `source`: link to more information on the font,\n///    or typekit/googlefonts as useful\n/// - `svgid`: optional suffix value for local SVG font `src`, e.g. `font-file.svg#svgid` (if omitted, defaults to `name`)\n/// - `<variant>`: describe any number of relative paths to locally-hosted\n///   font-files per variant: e.g. `regular`, `bold italic`, etc.\n///\n/// ```scss\n/// 'body-font': (\n///   'name': 'Source Sans Pro',\n///   'source': 'https://github.com/adobe-fonts/source-sans-pro'\n///   'stack': ('Helvetica Neue', 'Helvetica', 'Arial', 'sans-serif'),\n///   'regular': 'sans/sourcesanspro-regular-webfont',\n///   'italic': 'sans/sourcesanspro-italic-webfont',\n/// )\n/// ```\n///\n/// @group api_json-export\n///\n/// @example scss - sample map structure\n///   $herman: (\n///     'colors': (\n///       'brand-colors': (\n///         'brand-orange': '#c75000',\n///         'brand-blue': '#0d7fa5',\n///       ),\n///       'status-colors': (\n///         'go': '#657e1b',\n///         'yield': '#c75000',\n///       ),\n///     ),\n///     'fonts': (\n///       'body-font': (\n///         'name': 'Source Sans Pro',\n///         'stack': ('Helvetica Neue', 'Helvetica', 'Arial', 'sans-serif'),\n///         'regular': 'sans/sourcesanspro-regular-webfont',\n///         'italic': 'sans/sourcesanspro-italic-webfont',\n///       ),\n///     ),\n///     'sizes': (\n///       'text-sizes': (\n///         'root': '18px',\n///         'large': 'calc(1rem + 1.5vw)',\n///       ),\n///     ),\n///   );\n$herman: () !default;\n\n\n// Herman Export\n// -------------\n/// Encode a Sass map as a JSON-ready string,\n/// and print to CSS output as a persistent comment.\n///\n/// @group api_json-export\n///\n/// @param {map} $map [$herman] -\n///   Map to be encoded for JSON exporting\n///\n/// @example scss\n///   // Export to JSON\n///   @include herman-export;\n@mixin herman-export(\n  $map: $herman\n) {\n  $json: _herman-encode($map);\n  /*! json-encode: #{$json} */\n}\n"]}