// Herman Utilities
// ================


// Plural Types
// ------------
// A map of data-types used in herman,
// for correcting singular input
// so data is consistently stored with a plural access key.
//
// No need to display these in the docs…
//
// @access private
// @group api_sass-utilities
// @type map
// @see herman-add
$_herman-plural-types: (
  'color': 'colors',
  'size': 'sizes',
  'ratio': 'ratios',
  'font': 'fonts',
);


// Accoutrement Functions Per Type
// -------------------------------
// The accoutrement function to use
// when compiling a map for Herman export.
//
// No need to display these in the docs…
//
// @access private
// @group api_sass-utilities
// @type map
// @see accoutrement-add
$_herman-accoutrement-per-type: (
  'colors': 'color',
  'sizes': 'size',
  'ratios': 'ratio'
);


// Herman
// ------
/// A map of values to be exported to JSON.
///
/// The `$herman` map should be structured
/// with top-level keys representing individual sassdoc items.
/// Top-level values will often be a nested map
/// of the data to preview.
/// Use the `herman-add` or `accoutrement-add` mixins
/// to automatically populate
/// fonts, colors, sizes, and ratios from existing maps –
/// or construct your `$herman` map by hand,
/// following these guidelines…
///
/// ### Map structure:
///
/// Each type of preview value should be nested inside
/// a map that describes what type of data is being stored:
///
/// ```
/// $herman: (
///   'colors': (
///     /* color maps */
///   );
///   'sizes': (
///     /* color maps */
///   );
///   'ratios': (
///     /* color maps */
///   );
///   'fonts': (
///     /* color maps */
///   );
/// );
///
/// ### Colors:
///
/// Each color has an access name and value.
/// For us, that is often a map-key string,
/// and Sass hex/rgba output color:
///
/// ```
/// 'brand-colors': (
///   'brand-orange': '#c75000',
///   'brand-blue': '#0d7fa5',
/// )
/// ```
///
/// If you are storing colors in variables,
/// you may want to use name keys like `$brand-orange`
/// to represent the proper use of a color.
///
/// Color values can be in any valid web-color format –
/// hex, hsl/a, rgba/a, etc –
/// converted to a valid JSON string.
///
/// ### Sizes & Ratios
///
/// Size and ratio data is similar to colors,
/// organized into top-level groups that may contain
/// one or more size/ratio key:value pairs:
///
/// ```
/// 'font-ratios': (
///   'line-height': '1.4',
///   'minor-seventh': '16/9',
/// ),
/// 'text-sizes': (
///   'root': '18px',
///   'large': 'calc(1rem + 1.5vw)',
/// )
/// ```
///
/// Ratio values can be in any valid number,
/// and size values should be valid CSS lengths –
/// both converted to a valid JSON string.
///
/// ### Fonts:
///
/// Each font should have a top-level key of it's own,
/// since font-previews display a single font at a time.
/// The data map accepts:
///
/// - `name`: how the font should be referenced in CSS
/// - `stack`: optional list of font-stack fallbacks
/// - `source`: link to more information on the font,
///    or typekit/googlefonts as useful
/// - `<variant>`: describe any number of relative paths to locally-hosted
///   font-files per variant: e.g. `regular`, `bold italic`, etc.
///
/// ```
/// 'body-font': (
///   'name': 'Source Sans Pro',
///   'source': 'https://github.com/adobe-fonts/source-sans-pro'
///   'stack': ('Helvetica Neue', 'Helvetica', 'Arial', 'sans-serif'),
///   'regular': 'sans/sourcesanspro-regular-webfont',
///   'italic': 'sans/sourcesanspro-italic-webfont',
/// )
/// ```
///
/// @group api_sass-utilities
///
/// @example scss - sample map structure
///   $herman: (
///     'colors': (
///       'brand-colors': (
///         'brand-orange': '#c75000',
///         'brand-blue': '#0d7fa5',
///       ),
///       'status-colors': (
///         'go': '#657e1b',
///         'yield': '#c75000',
///       ),
///     ),
///     'fonts': (
///       'body-font': (
///         'name': 'Source Sans Pro',
///         'stack': ('Helvetica Neue', 'Helvetica', 'Arial', 'sans-serif'),
///         'regular': 'sans/sourcesanspro-regular-webfont',
///         'italic': 'sans/sourcesanspro-italic-webfont',
///       ),
///     ),
///     'sizes': (
///       'text-sizes': (
///         'root': '18px',
///         'large': 'calc(1rem + 1.5vw)',
///       ),
///     ),
///   );
$herman: () !default;


// Herman Add
// ----------
/// Add a map of colors, fonts, sizes, ratios, etc
/// to the `$herman` map for JSON-export,
/// converting values to JSON-ready strings,
/// with optional functions/args for compiling raw values.
/// @group api_sass-utilities
/// @param {String} $type -
///   The type of map being added,
///   e.g. `colors`, `fonts`,
///   `sizes`, or `ratios`.
/// @param {String} $key -
///   A key name for accessing this data in JSON —
///   should match the variable name,
///   unless `key` is otherwise set in the `@preview` annotation
/// @param {Map} $map -
///   A map of name/value pairs
/// @param {Arglist} $args… -
///   A function to use for compiling values before export,
///   and any additional arguments for the function
/// @output
///   Updated `$herman` map, ready for JSON export
/// @example scss
///   $brand-colors: (
///     'brand-blue': hsl(195, 85%, 35%),
///     'light-gray': 'brand-blue' ('tint': 80%, 'desaturate': 80%),
///   );
///   @include herman-add('colors', 'brand-colors', $brand-colors, 'color');
///   /* #{$herman} */
@mixin herman-add(
  $type,
  $key,
  $map,
  $args...
) {
  // pluralize type
  $type: map-get($_herman-plural-types, $type) or $type;

  // compile maps as needed
  @if (length($args) > 0) {
    $map: herman-map-compile($map, $args...);
  }

  // Update nested map by type
  $nested: map-get($herman, $type) or ();
  $nested: map-merge($nested, ($key: $map));
  $nested: ($type: $nested);

  // Merge nested map back into $herman
  $herman: map-merge($herman, $nested) !global;
}


// Accoutrement Add
// ----------------
/// Add [Accoutrement](http://oddbird.net/open-source/accoutrement/)
/// map-partials to both the Herman export map and
/// the appropriate global Accoutrement map variable –
/// e.g. colors are added to both `$herman` (compiled)
/// and `$colors` (raw).
/// @group api_sass-utilities
/// @param {String} $type -
///   The type of map being added,
///   e.g. `colors`, `fonts`,
///   `sizes`, or `ratios`.
/// @param {String} $key -
///   A key name for accessing this data in JSON —
///   should match the variable name,
///   unless otherwise set in the `@preview` annotation
/// @param {Map} $map -
///   A map of name/value pairs,
///   based on the Accoutrement syntax
/// @output
///   Updated `$herman` map, ready for JSON export
/// @example scss
///   $brand-colors: (
///     'brand-blue': hsl(195, 85%, 35%),
///     'light-gray': 'brand-blue' ('tint': 80%, 'desaturate': 80%),
///   );
///
///   @include accoutrement-add('color', 'brand-colors', $brand-colors);
///
///   /* Herman: */
///   /* #{$herman} */
///   /* --- */
///   /* Accoutrement-Colors: */
///   /* #{$colors} */
@mixin accoutrement-add(
  $type,
  $key,
  $map
) {
  // pluralize type
  $type: map-get($_herman-plural-types, $type) or $type;

  // find the proper accoutrement function
  $call: map-get($_herman-accoutrement-per-type, $type);

  // get-function, as needed
  $get: function-exists('get-function');
  $call: if($get and $call, get-function($call), $call);

  // merge into accoutrement-maps
  @if ($type == 'colors') {
    $colors: map-merge($colors, $map) !global;
  } @else if ($type == 'sizes') {
    $sizes: map-merge($sizes, $map) !global;
  } @else if ($type == 'ratios') {
    $ratios: map-merge($ratios, $map) !global;
  } @else if ($type == 'fonts') {
    $fonts: map-merge($fonts, ($key: $map)) !global;
  }

  // send proper arguments to herman-add
  $args: ($type, $key, $map);
  $args: if($call, append($args, $call), $args);
  @include herman-add($args...);
}


// Map Compile
// -----------
/// Pass the values of any map through a given function
/// (with optional arguments)
/// and return the compiled map.
/// This is used by `herman-add` and `accoutrement-add`,
/// but can also be accessed directly.
///
/// @group api_sass-utilities
///
/// @param {Map} $map -
///   A sass map with values that need to be compiled,
///   such as Accoutrement Colors or Sizes with adjustments
/// @param {String | Function} $function -
///   The function (or function name) to use in compiling values,
///   such as Accoutrement `color` and `size` functions
/// @param {Arglist} $args… -
///   Pass in any additional arguments for the function
/// @return {String | Any} -
///   An updated map,
///   with values compiled by a third-party function,
///   and converted to json-ready strings
/// @example scss
///   $brand-colors: (
///     'brand-orange': hsl(24, 100%, 39%),
///     'brand-blue': hsl(195, 85%, 35%),
///     'light-gray': 'brand-blue' ('tint': 80%, 'desaturate': 80%),
///   );
///   /* #{herman-map-compile($brand-colors, 'color')} */
@function herman-map-compile(
  $map,
  $function,
  $args...
) {
  $output: ();

  @each $key, $value in $map {
    @if length($args) > 0 {
      $value: append((), $value);
      $value: join($value, $args);
      $value: call($function, $value...);
    } @else {
      $value: call($function, $value);
    }

    $value: _herman-inspect($value);
    $output: map-merge($output, ($key: $value));
  }

  @return $output;
}



// Herman Inspect
// --------------
/// Convert any value into a json-export-ready string
/// @group api_sass-utilities
/// @access private
/// @param $value -
///   Any sass value to convert
/// @return {String} -
///   A string reprepesentation of the given value,
///   with leading zeros on numbers,
///   and quotes escaped for JSON
@function _herman-inspect(
  $value
) {
  $value: inspect($value);

  @if str-index($value, '.') == 1 {
    $value: '0' + $value;
  }

  @if str-index($value, '"') {
    $value: _herman-str-replace($value, '"', '\\"', true);
  }

  @return $value;
}


// String Replace
// --------------
/// Return a string, with a substring replaced
/// @group api_sass-utilities
/// @access private
/// @param {String} $string -
///   The base string to be manipulated
/// @param {String} $old -
///   A sub-string to look for, and replace,
///   inside the base string
/// @param {String} $new -
///   A sub string to insert
///   in place of the `$old` string
/// @param {Boolean} $replace-all [false] -
///   Replace all instances of the `$old` string
///   or just the first instance?
/// @return {String} -
///   Return the base string,
///   with one or more instances of a substring replaced
@function _herman-str-replace(
  $string,
  $old,
  $new: null,
  $replace-all: false
) {
  $return: $string;
  $i: str-index($string, $old);
  $n: str-length($old);

  @if $string == $old {
    $return: $new;
  } @else if $i {
    $a: if($i > 1, str-slice($string, 1, $i - 1), '');
    $z: str-slice($string, $i + $n);

    @if $replace-all {
      $z: _herman-str-replace($z, $old, $new, true);
    }

    $return: $a + if($new, $new, '') + $z;
  }

  @return $return;
}
