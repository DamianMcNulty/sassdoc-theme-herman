{"version":3,"sources":["webpack:////Users/jonny/Sites/sassdoc-theme-herman/scss/utilities/_json-api.scss"],"names":[],"mappings":"AAqLE","file":"styleguide_json.min.css","sourcesContent":["// JSON Export Utilities\n// ---------------------\n\n\n/// ## Exporting Styles to JSON\n///\n/// While many UX patterns will be rendered as HTML components,\n/// there are several abstract style patterns --\n/// like color-palettes and font-specimens --\n/// that never appear as components in the application.\n///\n/// Herman provides several annotations\n/// to help visualize these abstract patterns,\n/// but they require access to the raw Sass data.\n/// We do that using Sass maps\n/// (`key:value` object variables)\n/// and the `herman-export` mixin\n/// to generate JSON out of Sass variables.\n///\n/// @group api_json-export\n/// @see herman-export\n///\n/// @example scss\n///   $herman: (\n///     'colors': (\n///       'brand-colors': (\n///         'brand-orange': #c75000,\n///         'brand-blue': #0d7fa5,\n///       ),\n///     ),\n///   );\n///\n///   @include herman-export($herman);\n\n\n// Herman\n// ------\n/// Use the `$herman` map variable to collect and organize\n/// color, font, size, and ratio values for export.\n///\n/// The `$herman` map should be structured\n/// with top-level keys for each type of data,\n/// and nested maps of the individual items to preview.\n/// Use the `herman-add` mixin to automatically populate\n/// fonts, colors, sizes, and ratios from existing maps --\n/// or construct your `$herman` map by hand,\n/// following these guidelines...\n///\n/// ### Map structure\n///\n/// Each type of preview value should be nested\n/// under a key that describes what type of data is being stored:\n///\n/// ```scss\n/// $herman: (\n///   'colors': (\n///     /* color maps */\n///   );\n///   'sizes': (\n///     /* color maps */\n///   );\n///   'ratios': (\n///     /* color maps */\n///   );\n///   'fonts': (\n///     /* color maps */\n///   );\n/// );\n/// ```\n///\n/// ### Colors\n///\n/// Each color has an access name and value.\n/// The key will be used to identify the correct data\n/// for a given color-palette,\n/// and the data includes color `name:value` pairs,\n/// both in string format.\n///\n/// ```scss\n/// 'brand-colors': (\n///   'brand-orange': #c75000,\n///   'brand-blue': #0d7fa5,\n/// )\n/// ```\n///\n/// Color values can be in any valid web-color format --\n/// hex, hsl/a, rgba/a, etc.\n///\n/// ### Sizes & Ratios\n///\n/// Size and ratio data is similar to colors,\n/// organized into top-level groups that may contain\n/// one or more `name:value` pairs:\n///\n/// ```scss\n/// 'font-ratios': (\n///   'line-height': 1.4,\n///   'minor-seventh': 16/9,\n/// ),\n/// 'text-sizes': (\n///   'root': 18px,\n///   'large': calc(1rem + 1.5vw),\n/// )\n/// ```\n///\n/// Ratio values can be in any valid number,\n/// and size values should be valid CSS lengths.\n///\n/// ### Fonts\n///\n/// Each font should have a top-level key of its own,\n/// since font-previews display a single font at a time.\n/// The data map accepts:\n///\n/// - `name`: how the font should be referenced in CSS (if omitted, defaults to top-level key)\n/// - `stack`: optional string or list of font-stack fallbacks\n/// - `source`: link to more information on the font,\n///    or typekit/googlefonts as useful\n/// - `svgid`: optional suffix value for local SVG font `src`, e.g. `font-file.svg#svgid` (if omitted, defaults to `name`)\n/// - `<variant>`: describe any number of relative paths to locally-hosted\n///   font-files per variant: e.g. `regular`, `bold italic`, etc.\n///\n/// ```scss\n/// 'body-font': (\n///   'name': 'Source Sans Pro',\n///   'source': 'https://github.com/adobe-fonts/source-sans-pro'\n///   'stack': ('Helvetica Neue', 'Helvetica', 'Arial', 'sans-serif'),\n///   'regular': 'sans/sourcesanspro-regular-webfont',\n///   'italic': 'sans/sourcesanspro-italic-webfont',\n/// )\n/// ```\n///\n/// @group api_json-export\n///\n/// @example scss - sample map structure\n///   $herman: (\n///     'colors': (\n///       'brand-colors': (\n///         'brand-orange': '#c75000',\n///         'brand-blue': '#0d7fa5',\n///       ),\n///       'status-colors': (\n///         'go': '#657e1b',\n///         'yield': '#c75000',\n///       ),\n///     ),\n///     'fonts': (\n///       'body-font': (\n///         'name': 'Source Sans Pro',\n///         'stack': ('Helvetica Neue', 'Helvetica', 'Arial', 'sans-serif'),\n///         'regular': 'sans/sourcesanspro-regular-webfont',\n///         'italic': 'sans/sourcesanspro-italic-webfont',\n///       ),\n///     ),\n///     'sizes': (\n///       'text-sizes': (\n///         'root': '18px',\n///         'large': 'calc(1rem + 1.5vw)',\n///       ),\n///     ),\n///   );\n$herman: () !default;\n\n\n// Herman Export\n// -------------\n/// Encode a Sass map as a JSON-ready string,\n/// and print to CSS output as a persistent comment.\n///\n/// @group api_json-export\n///\n/// @param {map} $map [$herman] -\n///   Map to be encoded for JSON exporting\n///\n/// @example scss\n///   // Export to JSON\n///   @include herman-export;\n@mixin herman-export(\n  $map: $herman\n) {\n  $json: _herman-encode($map);\n  /*! json-encode: #{$json} */\n}\n\n\n\n// WEBPACK FOOTER //\n// /Users/jonny/Sites/sassdoc-theme-herman/scss/utilities/_json-api.scss"],"sourceRoot":""}